```table-of-contents
style: nestedList # TOC style (nestedList|inlineFirstLevel)
maxLevel: 0 # Include headings up to the speficied level
includeLinks: true # Make headings clickable
debugInConsole: false # Print debug info in Obsidian console
```
---
# 1. 객체

- Key 와 Value 로 구성된 속성의 집합
- 리터럴 `{}` 방식으로 객체를 생성 가능

## 1-1 프로퍼티

```
const 객체이름(user) = {
	key : value,
	name : james
	...
	(property),
}
```

* 마지막 프로퍼티 끝에 쉼표 올 수 있음
* 프로퍼티 키 이름엔 제약사항이 없음(for,let,return..)
  (문자/심볼형이 아닌 키 값은 문자열로 자동 형 변환)

* `__proto__`는 특별 프로퍼티 이름으로 예약어 

### 1-1-1 객체 밖에서 프로퍼티에 접근

- Value 재할당
	- 해당하는 Key 가 없을 경우 동적으로 속성 추가
	- 객체의 주소 값은 그대로이며 주소 같이 참조하는 원본 객체 데이터에 얕은 복사	
```
person.name = "kim" 
```

- Value 삭제
	- delete 키워드로 삭제 가능
```
delete person.name;
```

### 1-1-2 계산된 프로퍼티(computed property) 

- 프로퍼티 이름을 동적으로 받음
```
let fruit = prompt("어떤 과일을 구매하시겠습니까?", "apple");
let bag = {
	[fruit]: 5, // 변수 fruit에서 프로퍼티 이름을 동적으로 받음
};
alert( bag.apple ); // fruit에 "apple"이 할당되면 5 출력
```


### 1-1-3 단축 프로퍼티 

- 변수를 사용해 프로퍼티를 만듦

```
function makeUser(name, age) {
return {
		name: name,
	age,
};
}

let user = makeUser("John", 30);
alert(user.name); // John
```

### 1-1-4 프로퍼티 존재 확인 방법 

- for .. in 사용

### 1-1-5 프로퍼티 정렬 방식

- 정수 프로퍼티는 자동 정렬(변형 없이 정수에서 문자열 변환이 가능한 프로퍼티)
	- "49" 는 정수프로퍼티
	- "+49" , "1.2" 등은 아님
- 그 외 객체 추가한 순서대로 정렬

### 1-1-6 프로퍼티 접근법

- 대괄호 `[]`
	- 문자열, 배열, 함수에 모두 접근 가능
```
const person = {
	name : {
		lastName = "Hong",
		...
	},
	printHello:function(){
		...
	}
	...
};
console.log(person["name"]["lastName"]);
console.log(person["printhello"]());	
```

- 마침표 `.`
	* 객체 key에 공백이 있을 경우 접근 불가
```
console.log(peson."name");
```

* 접근법의 차이
	* 대괄호 표기법은 변수를 프로퍼티 키로 사용 가능 (점 표기법은 불가능)
```
let v = "name";
user.v // undefined
user[v] // james
```

## 1-2 메서드

- 메서드 : 객체 내에서 함수가 속성의 값일 때 함수를 지칭
- 객체 내 메서드 선언시 function 생략 가능
```
user = {
	sayHi() { // "sayHi: function()"과 동일.
			alert("Hello");
	}
};
```

### 1-2-1 객체 순회 메서드

#### 1-2-1-1 Map, Set, Array

- `keys(), values(), entries()`를 사용할 수 있는 자료구조는 다음과 같음
> 인자를 따로 받지 않음, 이터러블 객체 반환

#### 1-2-1-2 일반 객체

- `Object.keys(obj), values(obj), entries(obj)` : 일반 객체의 순회에 필요한 메서드
>인자로 obj를 받음, 진짜 배열 반환

#### 1-2-1-3 심볼형 프로퍼티의 순회

* `Object.keys, values, entries`는 심볼형 프로퍼티를 무시

- `Object.getOwnPropertySymbols` : 심볼형 키만 배열 형태로 반환해주는 메서드
- `Reflect.ownKeys(obj)`` : 키 전체를 배열 형태로 반환하는 메서드

### 1-2-2 객체를 배열로 변환하여 다시 객체로 변환하기

>원래 객체는 map/filter를 사용할 수 없지만 `Object.entries(obj)`를 사용해 
>객체의 키-값 쌍이 요소인 배열을 얻고 `Object.fromEntries(array)`를 적용해 
>배열을 다시 객체로 되돌림

```
let prices = {
  banana: 1,
  orange: 2,
  meat: 4,
};

let doublePrices = Object.fromEntries(
  Object.entries(prices).map(([key, value]) => [key, value * 2])
);
```

## 1-3 this 

- `this` 키워드를 사용하여 객체에 접근가능(객체 내 메서드에서 객체를 호출 가능)
* 모든 함수에 사용가능, this는 런타임에 결정( . 앞의 객체를 참조 )
* 객체 없이도 호출가능 ( 엄격모드일 경우 this == undefined )
  (엄격 모드가 아닐경우 this가 전역 객체(window)를 참조)
* 화살표 함수 내에서 this는 외부 컨텍스트를 참조 ( 자신의 this 없음 )
* this 값은 호출시점에 결정 (`.` 앞의 객체를 참조, `발화점`)

```
function makeUser() {
	return {
			name: "John",
			ref: this
	};
};
let user = makeUser();

// this 호출시 undefined 로 결정
// this가 함수로 호출됨
// ref: this 는 현재 this의 값(undefined)
alert( user.ref.name ); // Error: Cannot read property 'name' of undefined
```

```
function makeUser() {
	return {
		name: "John",
			ref() {
			return this;
			}
	};
};
let user = makeUser();

// ref() 메서드 this반환( makeUser() ), user.ref()는 user.this와 같다.
alert( user.ref().name ); // John
```

## 1-4 메서드 호출 체이닝 

- 메소드들의 반환값을 `this`로 설정하면 `.`으로 체인을 이룰 수 있음 

```
let ladder = {
	step: 0,
	up() {
		this.step++;
		return this;
	},
	down() {
		this.step--;
		return this;
	},
	showStep() {
			alert( this.step );
			return this;
	}
}

ladder.up().up().down().up().down().showStep(); // 1
```

### 1-4-1 옵셔널 체이닝 `?.`  

- 프로퍼티가 없는 중첩 객체를 안전하게 접근
>객체에 존재하지 않는 프로퍼티에 접근시 `&&`를 사용하였으나 코드가 길어짐
>`?.` 앞의 평가 대상이 `undefined/null` 일 경우 평가 종료, `undefined` 반환
>선언이 완료된 변수 대상으로만 동작 

  - 다양한 방식으로 조합가능
	- 메서드와 조합시 `?.()`
	- 프로퍼티와 조합시 `?.[]`
	- `delete`와 조합가능

* 옵셔널 체이닝은 연산자가 아닌 문법 구조체
> 옵셔널 체이닝은 할당 연산자 왼쪽에 올 수 없음

* 단락 평가 예시
```
let user = null;
let x = 0;
user?.sayhi(x++); // user === null 이므로 오른쪽 동작 X
alert(x); // 0, x 증가 안함 
````

## 1-5 객체 복사

- 참조에 의한 객체 복사
- 객체에서 `"==", "==="` 는 동일하게 작동

### 1-5-1 객체 복사방법 

- 1. 얕은복사 
	- `Object.assign(dest, [src1, src2, src3...])` 
> 목표객체(dest)에 src1,... 의 프로퍼티 모두를 dest 에 복사후 dest 반환
> 동일한 프로퍼티가 있을 경우 기존 값이 덮어씌워짐

- 2. 깊은복사
	- 라이브러리 `lodash` 의 메서드 `_.cloneDeep(obj)`` 사용 
	* Deepcopy 표준 알고리즘 =  [[Structured cloning algorithm]]
		- [DeepCopy Algorithm](https://html.spec.whatwg.org/multipage/structured-data.html#safe-passing-of-structured-data)

## 1-6 표준 내장 객체(Standard Built-in Object)

- String 
	- `length` : 문자열 길이 반환
	- `includes()` : 문자열이 대상 문자열에 포함시 true 아니면 false
	- `replace()` : 문자열과 일치하는 한 부분을 찾아서 다른 데이터로 변경한 새로운 문자열 반환
	- `replaceAll()` : 일치하는 모든 부분을 찾아서 다른 데이터로 변경한 새로운 문자열 반환
	- `split()` : 매개변수 인자로 구분자를 기준으로 문자열을 분리하여 배열로 반환
	- `toUpperCase()` : 문자열을 대문자로 변경
	- `trim()` : 대상 문자열의 앞,뒤 공백 제거
	- `indexOf()` : 대상 문자열과 일치하는 첫 번째 문자의 인덱스 반환 못 찾으면 -1 반환
	
- Array
	- `length`
	- `push()` : 배열 맨 뒤에 데이터 추가
	- `pop()` : 배열 맨 뒤 데이터 추출
	- `unshift()` : 배열 맨 앞 데이터 추가
	- `shift()` : 배열 맨 앞 데이터 추출
	- `sort() / reverse()` : 배열 정렬
	- `forEach()` : 배열의 요소를 하나씩 순회하며 callback 함수 호출
	- `filter()` : 배열의 요소를 하나씩 순회하며 콜백 함수 호출
		- true 반환하는 요소만 추출
		- 추출한 요소로 새로운 배열을 만들어 반환
	- `find()` : 주어진 판별 함수를 만족하는 배열의 첫 번째 값 반환
	- `findIndex()` : 주어진 판별 함수를 만족하는 배열의 첫 번째 인덱스 반환
	- `includes()`
	- `join()` : 배열의 모든 요소를 주어진 구분자로 합쳐 문자열로 반환

- Date
	* 인스턴스 생성 필수 : `const date = new date();`
	- `get/setFullyear()` : 4자리 년도
	- `get/setMonth()` : 월(0 ~ 11)
	- `get/setDate()` : 일(1 ~ 31)
	- `getDay()` : 요일(0 ~ 6)
	- `get/setTime()` : 1970년 1월 1일 12:00 이후의 시간을 밀리초 단위로 표시
	- `get/setHours()` : 시(0 ~ 23)
	- `get/setMinutes()` : 분(0 ~ 59)
	- `get/setSeconds()` : 초(0 ~ 59)
	- `get/setMilliseconds()` : 밀리초(0 ~ 999) 

- Math
	- `floor()` : 내림
	- `ceil()` : 올림
	- `round()` : 반올림
	- `random()` : 0 이상 1 미만 난수 반환
	- `max()` 
	- `pow(n,power)`

---

# 2. 메서드

## 2-1. 원시값(primitive)의 메서드

- 원시 값도 객체처럼 메서드 호출 가능
- 원시 값이 메서드/프로퍼티 접근시 원시 래퍼 객체(object wrapper)를 생성
- 메서드 사용 후 바로 삭제(해당 줄에서만 사용가능)
- 각 래퍼 객체는 원시 자료형의 이름을 그대로 사용
>null / undefined 는 메서드 없음

### 2-1-1 숫자형(Number)의 메서드

- `num.toString(base)` : 
> 숫자형을 `base` 진법으로 `num`을 표현한 것을 문자형으로 변환
> `base` 는 `2~36`까지 가능(`기본값 = 10`)

- 숫자를 그대로 메서드 호출시 점 2개 사용(`..`) :
> 첫번째 점을 소수부로 인식하여 오류발생
```
123..toString()
```

- `num.toFiexd(n)` : 
> num을 소수 n번자리까지 반올림하여 문자형으로 반환(소수부 길이를 0으로 채움)
> 정밀도 손실(loss of precision)을 방지할 수 있음
```
let sum = 0.1 + 0.2;
+sum.toFiexd(2) // 0.30
1.35 => 1.350000000...8882 이므로 반올림되어 1.4
6.35 => 6.34999999999... 이므로 버림 6.3
```

- `isNaN(arg)` : 
> arg를 숫자로 변환한 값이 NaN이면 true ( 숫자가 아닌 문자열 변환시 NaN)
> NaN은 자기 자신을 포함하여 어떤 값과도 같지 않음
```
NaN === NaN // false
```

- `isFinite(arg)` : 
> arg를 숫자로 변환한 값이 `NaN/Infinity/-Infinity` 가 아닌 경우 true
> 빈 문자나 공백 문자열은 0으로 취급

- `Object.is` : `===`와 엣지 케이스를 제외하면 같은 결과
```
//edge case
Object.is(NaN,NaN) === true
Object.is(0,-0) === false -> 0, -0은 다른 수로 취급
```

- `parseInt/parseFloat("문자열", 진수)` : 
>문자열에서 숫자를 읽다가 숫자가 아닌 수를 발견시(오류 발생) 읽기 종료 후
>수집한 숫자를 반환, 읽을 수 있는 수가 없을 때 NaN 반환

### 2-1-2 문자열의 메서드

> `length` : 프로퍼티 (함수가 아님) 

- `str.indexOf(substr, pos)` : 
> `str`의 `pos`부터 시작하여 부분 문자열 `substr`의 위치를 반환, 없으면 -1

- `str.charAt(pos)` :

- `str.includes(substr, pos)` :  
>`str`의 부분 문자열 `substr`이 있으면 `true` 아니면 `false`

- `str.startsWith/endsWIth(substr)` : 
> `str`이 부분 문자열 `substr`로 시작/끝나는지 여부(`true/false`)

- `str.slice(start [,end])` : 
> 슬라이싱( end 위치 글자 포함X )

- `str.substring(start [,end])` 
> `slice`와 같지만 `start`가 `end`보다 커도 똑같이 동작하며 
> 음수를 인수로 허용하지 않음(0으로 처리)

- `str.substr(start, [,length])` : 
> `start` 부터 `length`개의 글자를 반환

- `str.codePointAt(pos)` : 
> 문자열 코드를 반환
> 서로게이트 쌍 처리 가능 메서드

- `String.fromCodePoint(숫자)` : 
> 숫자 코드에 해당하는 글자 반환 ( = `\uXXXX` )
> 서로게이트 쌍 처리 가능 메서드

- `str.localeCompare(str2)` : 
> `str, str2`를 규칙에 따라 비교( str이 크면 양수, 같으면 0, 작으면 음수 ) 
> 모던 브라우저 대부분은 ECMA-402를 지원 -> 문자열 비교 규칙 메서드 정의
## 2-2 배열의 메서드

- 배열은 객체처럼 동작
> 자바스크립트 엔진은 배열의 요소를 인접 메모리 공간에 차례로 저장하여 연산속도를 높임
> 올바르지 않은 사용시 배열 최적화 기법이 동작하지 않음
> 숫자가 아닌 값을 프로퍼티 키로 사용, 배열 중간 값이 비거나 역순으로 채울 경우 연산속도 저하

- 선언
```
1. let arr = new Array(); // 모든 요소가 undefined
2. let arr = [];
```

- 큐
	- `push()` : 맨 끝에 요소 추가
	- `shift()` : 제일 앞 요소를 꺼낸 후 나머지 요소를 앞으로 밀어냄
	- `unshift()` : 배열 앞에 요소 추가
- 스택
	- `push()` : 스택 끝에 요소를 추가
	- `pop()` : 스택 끝 요소를 꺼냄
- 배열 순회
	- `for..of` 를 통해 요소를 순회가능
	* 객체이므로 `for..in`을 통해 순회가능하나 객체에 비해 느림
- `length`  :
	- `length`의 값을 할당가능(배열을 자름)
```
arr.length = 0; => 배열 비우기
```
- `toString` :
	- 배열의 요소를 쉼표로 구분한 문자열이 반환
	- 배열은 `toPrimitive, valueOf` 메서드 없음
```
[1,2] + 3 == "1,23"
```

- 배열도 객체이므로 `delete` 로 요소를 지울 수 있으나 그 자리가 줄어들지 않고 `undefined`을 할당

- `arr.slice()` : 
> 배열 복사본 반환

 - `arr.splice(index[, deleteCount, elem1, ..., elemN])` : 
 >`index`번 요소부터 `deleteCount` 수 만큼의 요소를 삭제 후 `elem1 ..` 개의 요소를 추가
 
- `arr.concat(arg1, arg2, ...)` : 
> 기존 배열 `arr`에 인수를 추가하여 새로운 배열을 생성, 인수가 배열일 경우 배열의 모든 값 복사
> 인수가 객체일 경우 객체가 통으로 복사

- `[Symbol.isConcatSpreadable]` :
> 객체에 특수 프로퍼티 존재시 객체를 배열로 취급하여 프로퍼티의 값이 복사
```
let arr = [1, 2];
let arrayLike = {
	0: "something",
	1: "else",
	[Symbol.isConcatSpreadable]: true,
	 length: 2
};
````

- `arr.forEach( function(itme, index, array) )` : 
> 주어진 함수를 배열 요소 각각에 대해 실행
	
- `arr.indexOf/lastIndexOf(itme, from)`

- `arr.includes(item, from)`

- `arr.find( function(itme,index,array), thisArg )` : 
>특정 조건에 맞는 하나의 객체를 찾아 반환
```
let users = [
	{id: 1, name: "John"},
	{id: 2, name: "Pete"},
	{id: 3, name: "Mary"}
];
let user = users.find(item => item.id == 1);
alert(user.name); // John
```

- `arr.findIndex()` : 
> 특정 조건에 맞는 객체의 인덱스 반환

- `arr.filter(function, thisArg)` : 
>특정 조건에 맞는 여러 객체를 담은 배열을 반환

- `arr.map(function, thisArg)` : 
>배열 요소 전체를 대상으로 함수 호출하고 결과를 배열로 반환
```
let lengths = ["Bilbo", "Gandalf", "Nazgul"].map(item => item.length); // 5,7,6
```

- `arr.sort(function)` : 
>배열의 요소를 문자열로 취급하여 배열 자체를 재 정렬
>숫자로 구성된 배열을 제대로 정렬하려면 함수가 필요
```
1.
	function compareNumeric(a, b) {
		 if (a > b) return 1; 
		 if (a == b) return 0;
		 if (a < b) return -1;
	}

2.
	arr.sort( (a,b) => a - b );
```
 
 - `arr.reverse()` : 
 > 역순 정렬
 
-  `arr.reduce( function( accumulator, item, index, array ) )` : 
> 이전 함수의 결과를 `accumulator`에 저장하여 모든 배열 요소를 순회
> 초기값 미 지정시 배열의 첫 번째 요소(비어있으면 오류)

- `arr.reduceRight` :

- `Array.isArray()` :  
> 배열이면 `true`
> 자바스크립트에서 배열은 객체로 취급하여 `typeof` 연산시 `object`로 나옴( 객체와 구분 불가 )
	
### 2-2-1 매개변수 `thisArg` 

> 객체 내 this를 사용하는 메소드를 배열 검색 필터의 인자로 지정시
> thisArg를 사용하면 this를 객체로 설정가능 
> 미지정시 메소드가 단독함수가 되어 메소드 내부의 `this`는 `undefined`되어 에러 발생

```
let army = {
  minAge: 18,
  maxAge: 27,
  canJoin(user) {
    return user.age >= this.minAge && user.age < this.maxAge;
  }
};

let soldiers = users.filter(army.canJoin, army);
	= users.filter(user => army.canJoin(user));
```

### 2-2-2 배열과 문자열 변환

- `str.split(delim, num)` : 
>`구분자(delimiter)` 기준 문자열을 쪼개 길이가 `num`인 배열로 저장
> num 보다 큰 요소는 무시

- `arr.join(glue)` : 배열의 요소를 `glue`를 사용해 합쳐서 문자열로 변환

## 2-3 Date() 객체와 메서드

- `new Date()` 를 통해 객체 호출 이후 사용
```
let days = new Date( year, month, date, hours, minutes, seconds, ms)
	- year : 반드시 4자리
	- month : 0~11	
	- date : 없을 경우 1일
	- hours/minutes/seconds/ms : 없을 경우 0
```

- 인수 없이 호출시 현재 날짜 시간이 저장된 `Date` 객체 반환
```
let now = new Date() //Wed Sep 06 2023 16:03:34 GMT+0900 (한국 표준시)

// 인수로 `milliseconds`를 받을시 UTC 기준(UTC+0) 1970년 1월 1일 0시 0분 0초에서  
// milliseconds 밀리초(1/1000 초) 후의 시점이 저장된 Date 객체가 반환
// 1970년 기준으로 흘러간 밀리초는 타임스탬프(timestamp)라고 부름
let nextday = new Date(13241200)

// 인수로 문자열을 받을시 자동으로 구문분석(parsed)
let stringDay = new Date("1997-09-02")
```

### 2-3-1 Date() 객체의 메서드

#### 2-3-1-1 날짜 반환 메서드

- `getFullYear()` : 연도(네 자릿수)를 반환
- `getYear()` : 두자리 수 연도를 반환(비표준)
- `getMonth()` : 월을 반환합니다(0 이상 11 이하).
- `getDate()` : 일을 반환합니다(1 이상 31 이하). 
- `getHours(), getMinutes(), getSeconds(), getMilliseconds()` : 시, 분, 초, 밀리초를 반환
>`get` 다음 `UTC`를 붙이면 런던 기준 값이 나옴

- `getDay()` : 요일 반환(0~6)
- `getTime()` : `1970년 1월 1일 00시 00분 00초 사이의 간격`(밀리초 단위)인 타임스탬프를 반환
- `getTimezoneOffset()` : 현지 시간과 표준 시간의 차이(분)를 반환

#### 2-3-1-2 날짜 설정 메서드

- `setFullYear(year, [month], [date])`
- `setMonth(month, [date])`
- `setDate(date)`
- `setHours(hour, [min], [sec], [ms])`
- `setMinutes(min, [sec], [ms])`
- `setSeconds(sec, [ms])`
- `setMilliseconds(ms)
- `setTime(milliseconds)`
> `1970년 1월 1일 00:00:00 UTC` 부터 밀리초 이후를 나타내는 날짜를 설정
> `setTime()`을 제외한 모든 메서드는 `setUTCHours()`같이 표준시에 따라 날짜 구성 요소를 설정
> `setHours()`와 같은 메서드는 여러 개의 날짜 구성요소를 동시에 설정 가능
> 메서드의 인수에 없는 구성요소는 변경되지 않음

#### 2-3-1-3 기타 메서드

- `Date.now()` :
>`new Date().getTime()`과 의미론적으로 동일하지만 중간에 Date 객체를 만들지 않는음
> 따라서 `new Date().getTime()`를 사용하는 것보다 빠르고 가비지 컬렉터의 일을 덜어줌
> 모던 자바스크립트 엔진은 아주 많이 실행된 코드인 'hot code’를 대상으로 최적화를 수행

- `Date.parse(str)` :
> 문자열에서 날짜를 읽어옴(단 `YYYY-MM-DDTHH:mm:ss.sssZ` 의 형태)
> 조건에 맞지 않으면 NaN 반환
```
YYYY-MM-DD : 날짜(연-월-일)
T : 구분 기호로 쓰임
HH:mm:ss.sss : 시:분:초.밀리초
Z : +-hh:mm 형식의 시간대를 나타냄. Z가 한 글자인 경우엔 UTC+0을 나타냄

// YYYY-MM-DD, YYYY-MM, YYYY같이 더 짧은 문자열 형식도 가능
```

### 2-3-2 자동 고침(autocorrection)

- 범위를 벗어나는 값을 설정하려고 하면 자동 고침 기능이 활성화되면서 값이 자동으로 수정
- 윤년을 생각할 필요 없이 자동 계산 
- 0이나 음수를 설정하면 전날의 값으로 계산

---

# 3. 구조 분해 할당

- 객체나 배열을 변수로 분해(대괄호 사용)

## 3-1 배열

- 사용법
```
let arr = ["Bora", "Lee"]
let [firstName, surname] = arr;
```

* 할당할 값이 없으면 undefined로 취급
* 기본 값 설정 가능( 표현식, 함수도 가능)
```
let [ name = "Guest" , surname= "Anonymous" ] = ["jame"];
```

* 쉼표를 사용하면 필요하지 않은 배열 요소를 버릴 수 있음

```
let [firstName, , title] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];
// 두 번째 요소는 필요하지 않음
// 네 번째 요소 할당하지 않았음으로 생략
```

* 스프레드 변수`...`을 사용하면 나머지 요소를 모아서 새로운 배열을 가져 올 수 있음
> 변수가 가장 마지막에 위치해야함

```
let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];
//`rest`이라는 배열이 형성

alert(name1); // Julius
alert(name2); // Caesar

alert(rest[0]); // Consul
alert(rest[1]); // of the Roman Republic
alert(rest.length); // 2
```

* 할당 연산자 우측엔 모든 이터러블이 올 수 있음
* 할당 연산자 좌측엔 할당할 수 있는 모든 것이 올 수 있음

### 3-1-1 for..of 문에서의 응용

```
let user = {
  name: "John",
  age: 30
};

for (let [key, value] of Object.entries(user)) {
  alert(`${key}:${value}`); // name:John, age:30이 차례대로 출력
}
```

### 3-1-2 변수 교환 트릭

```
let guest = "Jane";
let admin = "Pete";

// 변수 guest엔 Pete, 변수 admin엔 Jane이 저장되도록 값을 교환함
[guest, admin] = [admin, guest];
```

## 3-2 객체

- 사용법
```
let {var1, var2} = { var1:... , var2:...}
```

```
let options = {
  title: "Menu",
  width: 100,
  height: 200
};

let {title, width, height} = options;
```

- 프로퍼티 순서는 중요하지 않음
- 다른 이름의 프로퍼티 값 설정시 콜론`:` 사용
```
let {width: w, height: h, title} = options;
```

* 자바스크립트는 표현식이 아닌 `{...}`를 코드 블록으로 인식함
>따라서 이미 선언한 변수에 구조분해할당을 시전할 경우 괄호`(...)`로 감싸야함
```
let title, width, height;
({title, width, height} = {title: "Menu", width: 200, height: 100});
```

## 3-3 중첩구조분해

```
let options = {
  size: {
    width: 100,
    height: 200
  },
  items: ["Cake", "Donut"],
  extra: true
};

let {
  size: { // size는 여기,
    width,
    height
  },
  items: [item1, item2], // items는 여기에 할당함
  title = "Menu" // 분해하려는 객체에 title 프로퍼티가 없으므로 기본값을 사용함
} = options
```

```
let options = {
  title: "My menu",
  items: ["Item1", "Item2"]
};

function showMenu({
  title = "Untitled",
  width: w = 100,  // width는 w에,
  height: h = 200, // height는 h에,
  items: [item1, item2] // items의 첫 번째 요소는 item1에, 두 번째 요소는 item2에 할당함
}) {
  alert( `${title} ${w} ${h}` ); // My Menu 100 200
  alert( item1 ); // Item1
  alert( item2 ); // Item2
}

showMenu(options);

showMenu({}); // 모든 인수에 기본값이 할당됩니다. -> 빈 객체를 명시적으로 전달하면 기본값 할당
showMenu(); // 에러가 발생할 수 있습니다.

function showMenu({ title = "Menu", width = 100, height = 200 } = {}) {
  alert( `${title} ${width} ${height}` );
}

showMenu(); // Menu 100 200
```
 
---
#object #method #property