# 1. 이벤트 루프

- 태스크(=마이크로태스크, 매크로)를 기다리고 처리하는 루프

  > 먼저 들어온 태스크를 순차적으로 처리하며 태스크가 없는 경우 잠들어있다가 추가되면 처음부터 시작함

  > 태스크가 없는 경우 CPU 자원 소비는 0에 가까워지고 엔진은 잠듦

- 태스크에는 다음의 예시가 존재

  - 외부 스크립트
  - 마우스 클릭 등 이벤트 핸들러
  - 콜백 함수 등

- 엔진이 바쁠 경우 새로 추가되는 태스크는 큐(= 매크로태스크 큐)에 추가됨

  > 엔진이 특정 태스크를 처리하는 동안 렌더링이 절대 일어나지 않음

  > 응답 없는 페이지(Page Unresponsive)는 무한 루프에 빠질 경우 발생

## 1-1 웹 워커

- 별도의 백그라운드 스레드에서 코드를 병렬적으로 실행 가능

  > 웹 워커는 DOM에 접근 할 수는 없지만 여러 CPU 코어를 동시에 사용 가능

  > 메인 스레드와 별개의 이벤트 루프, 고유 변수가 존재하며 메인 스레드와 메시지 교환 가능

```
menu.onclick = function(){
	...
	let customEvent = new CustumEvent("menu-open", {
		bubbles : true
	});

	setTimeout(()=> menu.dispatchEvent(customEvent));
}

```

## 1-2 이벤트 루프 처리 개요

- 자바스크립트 엔진은 단일 호출 스택을 사용
- DOM, AJAX, Timer 는 Web API 영역에 따로 정의되어있음

  > 비동기 호출 함수 `setTimeout, XMLHttpRequest` 등은 자바스크립트 엔진 외부에 구현되어 있음

- 실제 자바스크립트 구동환경에서는 여러개의 스레드가 사용되어
  > 단일 호출 스택을 사용하는 자바스크립트 엔진과 상호 연동하는 장치가 이벤트 루프

## 1-3 비동기 API와 try-catch

```
// (A)
$('.btn').click(function() {
    try {
		// (B)
        $.getJSON('/api/members', function (res) {
            // 에러 발생 코드
        });
    } catch (e) {
        console.log('Error : ' + e.message);
    }
});
```

> - 버튼 클릭시 콜백함수 A는 브라우저의 XMLHttpRequest API를 통해
> - 서버로 비동기 요청을 보낸 뒤 실행을 마치고 호출 스택에서 바로 제거됨
> - 이후 콜백 B를 태스크 큐에 추가하여 이벤트 루프에 의해 실행되지만 콜백 A는 이미 콜 스택에 없음
> - 따라서 B는 독립적인 컨텍스트에서 실행하여 A 내부의 try-catch 문에 영향을 받지 않음
> - 따라서 비동기 에러 관리시 전역으로 try-catch 처리해야함

---

# 2. 태스크

- 태스크는 마이크로태스크와 매크로태스크로 나뉨

## 2-1 마이크로태스크

- 마이크로태스크는 코드를 사용해서만 만들 수 있음(주로 프라미스를 사용)
- 표준API인 `queueMicrotask(func)`를 사용하면 함수를 마이크로태스크 큐에 넣을 수 있음
- 마이크로 태스크는 매크로태스크 보다 우선순위가 높음

## 2-2 매크로태스크

- 매크로태스크는 스크립트, 렌더링, 이벤트, `setimeout()`호출 등을 의미함
- 이러한 호출들은 Web API를 거친 후 매크로태스크 큐에 저장

```
// 로딩 함수 구현 -> 잘못된 처리방식
// (A)
button.click(()=>{
	// (B)
	showWaitingMessage();
	// (C)
	/* 로딩 이후 실행할 함수 */
})

// 로딩 함수 구현 -> 올바른 방식
// (A)
button.click(()=>{
	// (B)
	showWaitingMessage();
	// (C)
	setTimeout(()=>{ /*로딩 이후 실행할 긴 함수*/ })
})
```

> - 콜백 A가 호출하여 매크로태스크를 수행 -> B를 호출하여 렌더링 요청, 그러나 마이크로태스크 처리를 기다림
> - 따라서 로딩 함수가 렌더링되지않고 마이크로태스크 C까지 처리 후 렌더링이 수행됨
> - 지연시간이 0인 `setTimeout()` 를 호출하여 함수 C를 매크로태스크 큐로 보내면 B의 렌더링 이후 C가 실행됨

## 2-3 태스크 처리 방식

- 일반적인 동기 호출은 콜 스택에서 처리하고 마이크로태스크는 큐로 보냄

  > 자바스크립트 엔진은 매크로태스크 하나를 처리하면 다음 매크로태스크를 처리하기 전

  > 마이크로태스크 전부를 처리한 뒤 매크로태스크를 처리함

  > 애플리케이션 환경에 영향을 받지 않고 모든 마이크로태스크를 동일한 환경에서 처리 가능

---
